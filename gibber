#!/usr/bin/env python

'''
A program for generating gibberish with markov chains.

Call it with -h for more info.

'''
## Copyright (C) 2017 Andrew "Drew" Dudash
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import argparse
import random
from collections import defaultdict
from itertools import izip, islice

class MarkovChainGenerator(object):
    'Generates chains of text with a markov chain.'
    def __init__(self, source):
        'Create a new Markov chain generator from the given source words.'
        self.source = source
        self.stochastic_matrix = defaultdict(lambda : defaultdict(lambda : 0))
        for first, second in izip(source, islice(source, 1, None, None)):
            self.stochastic_matrix[first][second] += 1
        for first in source:
            accum = 0
            for second in self.stochastic_matrix[first]:
                accum += self.stochastic_matrix[first][second]
            if accum:
                for second in self.stochastic_matrix[first]:
                    self.stochastic_matrix[first][second] /= accum

    def generate_next_word(self, first):
        'Pick a new word based on the previous one.'
        n = random.random()
        min_bound = 0
        max_bound = 0
        for second in self.stochastic_matrix[first].keys():
            max_bound += self.stochastic_matrix[first][second]
            if min_bound <= n <= max_bound:
                return second
            min_bound = max_bound
        return random.choice(self.source)

    def generate_words(self, length):
        'Returns a markov chain of the given length.'
        first = random.choice(self.source)
        words = [first]
        for _ in xrange(length):
            second = self.generate_next_word(first)
            words.append(second)
            first = second
        return words

if __name__ == '__main__':
    ## Code for setting up the argument parsing.
    parser = argparse.ArgumentParser(
        description = '''This program uses text files to generate gibberish.
Copyright (C) 2017  Andrew "Drew" Dudash.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it under certain conditions.'''
    )
    parser.add_argument(
        '--file',
        required = True,
        help = 'The text file to base gibberish off of.'
    )
    parser.add_argument(
        '--seperator',
        default = ' ',
        help = 'What to seperate the sequence of words generated by this program with.')
    group = parser.add_mutually_exclusive_group(required = True)
    group.add_argument(
        '--words',
        type = int,
        help = 'The amount of words to generate.'
    )
    group.add_argument(
        '--bytes',
        type = int,
        help = 'The amount of bytes to generate.'
    )

    ## The actual main body is below.
    args = parser.parse_args()
    with file(args.file) as f_obj:
        markov = MarkovChainGenerator(
            f_obj.read().split()
        )
    if args.words:
        print args.seperator.join(
            markov.generate_words(args.words)
        )
    else:
        print args.seperator.join(
            markov.generate_words(args.bytes)
        )[:args.bytes] #TODO! This could be done more efficiently.

